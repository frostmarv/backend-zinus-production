// src/modules/workable-bonding/workable-bonding.service.ts
import { Injectable } from '@nestjs/common';
import { DataSource } from 'typeorm';

@Injectable()
export class WorkableBondingService {
  constructor(private dataSource: DataSource) {}

  // ───────────────────────────────────────────────
  // Dapatkan semua planned week per (shipToName, sku)
  // ───────────────────────────────────────────────
  private async getPlannedWeeks(): Promise<any[]> {
    return await this.dataSource.query(`
      SELECT 
        c.customer_name AS shipToName,
        p.sku,
        poi.week_number AS week,
        SUM(poi.planned_qty) AS quantityOrder
      FROM production_order_items poi
      JOIN production_orders po ON poi.orderOrderId = po.order_id
      JOIN customers c ON po.customerCustomerId = c.customer_id
      JOIN products p ON poi.productProductId = p.product_id
      WHERE poi.week_number IS NOT NULL AND p.category = 'FOAM'
      GROUP BY c.customer_name, p.sku, poi.week_number
      ORDER BY c.customer_name, p.sku, poi.week_number
    `);
  }

  // ───────────────────────────────────────────────
  // Hitung status produksi per (shipToName, sku, week)
  // ───────────────────────────────────────────────
  private async calculateProductionStatus(): Promise<Map<string, any>> {
    const planned = await this.getPlannedWeeks();
    const skuWeekMap = new Map<string, any>();

    // Inisialisasi semua planned week
    for (const p of planned) {
      const key = `${p.shipToName}|${p.sku}|${p.week}`;
      skuWeekMap.set(key, {
        shipToName: p.shipToName,
        sku: p.sku,
        week: p.week,
        quantityOrder: p.quantityOrder,
        bonding: 0,
        max_cutting: 0,
        min_net_qty: 0,
        layers: {} as Record<number, number>,
      });
    }

    // Ambil data aktual
    const actualData = await this.getRawWorkableData();
    for (const row of actualData) {
      const key = `${row.shipToName}|${row.sku}|${row.week}`;
      const existing = skuWeekMap.get(key);
      if (existing) {
        existing.bonding = row.bonding_qty || 0;
        existing.max_cutting = Math.max(existing.max_cutting, row.cutting_qty);
        existing.layers[row.layer_index] = row.net_qty;
      } else {
        // Jika tidak ada planned, tetap buat entri (edge case)
        skuWeekMap.set(key, {
          shipToName: row.shipToName,
          sku: row.sku,
          week: row.week,
          quantityOrder: 0,
          bonding: row.bonding_qty || 0,
          max_cutting: row.cutting_qty,
          layers: { [row.layer_index]: row.net_qty },
        });
      }
    }

    // Hitung min_net_qty & remainProduksi
    for (const entry of skuWeekMap.values()) {
      const netQtys = Object.values(entry.layers);
      entry.min_net_qty = netQtys.length > 0 ? Math.min(...netQtys) : 0;
      entry['Remain Produksi'] = entry.quantityOrder - entry.bonding;
    }

    return skuWeekMap;
  }

  // ───────────────────────────────────────────────
  // 1. WORKABLE BONDING (VIEW 5) + FULL AUTO-ADVANCE
  // ───────────────────────────────────────────────
  async getWorkableBonding(): Promise<any[]> {
    const statusMap = await this.calculateProductionStatus();
    const skuGroups = new Map<string, any[]>();

    for (const entry of statusMap.values()) {
      const key = `${entry.shipToName}|${entry.sku}`;
      if (!skuGroups.has(key)) skuGroups.set(key, []);
      skuGroups.get(key)!.push(entry);
    }

    const result: any[] = [];
    for (const weeks of skuGroups.values()) {
      weeks.sort((a, b) => a.week - b.week);
      const active = weeks.find(w => w['Remain Produksi'] > 0);
      if (active) {
        result.push({
          week: active.week,
          shipToName: active.shipToName,
          sku: active.sku,
          quantityOrder: active.quantityOrder,
          workable: Math.max(active.min_net_qty - active.bonding, 0),
          bonding: active.bonding,
          'Remain Produksi': active['Remain Produksi'],
          status: active['Remain Produksi'] <= 0
            ? 'Completed'
            : active.max_cutting > 0
              ? 'Running'
              : 'Not Started',
          remarks: active['Remain Produksi'] <= 0
            ? 'Bonding completed'
            : active.max_cutting > 0
              ? 'Cutting in progress'
              : 'Waiting for cutting',
        });
      }
    }

    return result.sort((a, b) =>
      a.shipToName.localeCompare(b.shipToName, undefined, { sensitivity: 'base' }) ||
      a.sku.localeCompare(b.sku, undefined, { sensitivity: 'base' })
    );
  }

  // ───────────────────────────────────────────────
  // 2. WORKABLE BONDING DETAIL (VIEW 6) + FULL AUTO-ADVANCE
  // ───────────────────────────────────────────────
  async getWorkableDetail(): Promise<any[]> {
    const statusMap = await this.calculateProductionStatus();
    const skuGroups = new Map<string, any[]>();

    for (const entry of statusMap.values()) {
      const key = `${entry.shipToName}|${entry.sku}`;
      if (!skuGroups.has(key)) skuGroups.set(key, []);
      skuGroups.get(key)!.push(entry);
    }

    const layerNames = { 1: 'Layer 1', 2: 'Layer 2', 3: 'Layer 3', 4: 'Layer 4', 5: 'Hole' };
    const emptyLayers = { 'Layer 1': 0, 'Layer 2': 0, 'Layer 3': 0, 'Layer 4': 0, 'Hole': 0 };

    const result: any[] = [];
    for (const weeks of skuGroups.values()) {
      weeks.sort((a, b) => a.week - b.week);
      const active = weeks.find(w => w['Remain Produksi'] > 0);
      if (active) {
        const layers = { ...emptyLayers };
        for (const [idx, qty] of Object.entries(active.layers)) {
          const name = layerNames[Number(idx)];
          if (name) layers[name] = qty;
        }

        result.push({
          shipToName: active.shipToName,
          sku: active.sku,
          week: active.week,
          quantityOrder: active.quantityOrder,
          ...layers,
          workable: Math.max(active.min_net_qty - active.bonding, 0),
          bonding: active.bonding,
          'Remain Produksi': active['Remain Produksi'],
          status: active['Remain Produksi'] <= 0
            ? 'Completed'
            : active.max_cutting > 0
              ? 'Running'
              : 'Not Started',
          remarks: active['Remain Produksi'] <= 0
            ? 'Bonding completed'
            : active.max_cutting > 0
              ? 'Cutting in progress'
              : 'Waiting for cutting',
        });
      }
    }

    return result.sort((a, b) =>
      a.shipToName.localeCompare(b.shipToName, undefined, { sensitivity: 'base' }) ||
      a.sku.localeCompare(b.sku, undefined, { sensitivity: 'base' })
    );
  }

  // ───────────────────────────────────────────────
  // 3. WORKABLE BONDING NG (VIEW 7) — FULLY SYNCHRONIZED
  // Mengikuti EXACTLY week aktif dari bonding
  // ───────────────────────────────────────────────
  async getWorkableReject(): Promise<any[]> {
    // Dapatkan week aktif
    const activeWeeks = new Map<string, number>();
    const bondingData = await this.getWorkableBonding();
    for (const row of bondingData) {
      activeWeeks.set(`${row.shipToName}|${row.sku}`, row.week);
    }

    if (activeWeeks.size === 0) return [];

    // Ambil data NG per layer
    const ngData = await this.dataSource.query(`
      SELECT 
        br.sku,
        COALESCE(br.s_code, 'MAIN') AS s_code,
        SUM(br.ng_quantity) AS ng_qty
      FROM bonding_reject br
      WHERE br.status != 'CANCELLED'
      GROUP BY br.sku, COALESCE(br.s_code, 'MAIN')
    `);

    const replacementData = await this.dataSource.query(`
      SELECT 
        br.sku,
        COALESCE(br.s_code, 'MAIN') AS s_code,
        SUM(COALESCE(rp.processed_qty, 0)) AS replacement_qty
      FROM bonding_reject br
      LEFT JOIN replacement_progress rp 
        ON br.id = rp.bonding_reject_id
      WHERE br.status != 'CANCELLED'
        AND rp.status IN ('IN_PROGRESS', 'COMPLETED')
      GROUP BY br.sku, COALESCE(br.s_code, 'MAIN')
    `);

    const layerMap = await this.dataSource.query(`
      SELECT 
        p.sku,
        COALESCE(al.second_item_number, 'MAIN') AS s_code,
        COALESCE(al.layer_index, 1) AS layer_index
      FROM products p
      LEFT JOIN assembly_layers al ON p.product_id = al.productProductId
      WHERE p.category = 'FOAM'
    `);

    // Build maps
    const replMap = new Map<string, number>();
    for (const r of replacementData) {
      replMap.set(`${r.sku}|${r.s_code}`, r.replacement_qty);
    }

    const layerIndexMap = new Map<string, number>();
    for (const l of layerMap) {
      layerIndexMap.set(`${l.sku}|${l.s_code}`, l.layer_index);
    }

    // Gabungkan NG + layer
    const ngWithLayer: any[] = [];
    for (const ng of ngData) {
      const key = `${ng.sku}|${ng.s_code}`;
      const layer_index = layerIndexMap.get(key) || 1;
      const replacement_qty = replMap.get(key) || 0;
      ngWithLayer.push({
        sku: ng.sku,
        layer_index,
        ng_qty: ng.ng_qty,
        replacement_qty,
      });
    }

    // Assign ke active week
    const result: any[] = [];
    const layerNameMap: Record<number, string> = {
      1: 'Layer 1',
      2: 'Layer 2',
      3: 'Layer 3',
      4: 'Layer 4',
      5: 'Hole',
    };

    for (const [skuKey, week] of activeWeeks) {
      const [shipToName, sku] = skuKey.split('|');
      // Cari NG untuk SKU ini
      const ngItems = ngWithLayer.filter(item => item.sku === sku);
      if (ngItems.length === 0) {
        // Tetap buat entri kosong per layer jika tidak ada NG
        for (const [layerIdx, layerName] of Object.entries(layerNameMap)) {
          result.push({
            shipToName,
            sku,
            week: Number(week),
            layer_index: Number(layerIdx),
            layer_name: layerName,
            ng_qty: 0,
            replacement_qty: 0,
            net_ng_qty: 0,
            adjusted_net_ng: 0,
          });
        }
      } else {
        for (const item of ngItems) {
          const net_ng_qty = item.ng_qty - item.replacement_qty;
          result.push({
            shipToName,
            sku,
            week: Number(week),
            layer_index: item.layer_index,
            layer_name: layerNameMap[item.layer_index] || `Layer ${item.layer_index}`,
            ng_qty: item.ng_qty,
            replacement_qty: item.replacement_qty,
            net_ng_qty,
            adjusted_net_ng: Math.max(net_ng_qty, 0),
          });
        }
      }
    }

    return result.sort((a, b) =>
      a.shipToName.localeCompare(b.shipToName, undefined, { sensitivity: 'base' }) ||
      a.sku.localeCompare(b.sku, undefined, { sensitivity: 'base' }) ||
      a.week - b.week ||
      a.layer_index - b.layer_index
    );
  }

  // ───────────────────────────────────────────────
  // HELPER: Raw data aktual (cutting, bonding, NG)
  // ───────────────────────────────────────────────
  private async getRawWorkableData(): Promise<any[]> {
    return await this.dataSource.query(`
      SELECT 
        c.customer_name AS shipToName,
        p.sku,
        poi.week_number AS week,
        COALESCE(al.second_item_number, 'MAIN') AS s_code,
        COALESCE(al.layer_index, 1) AS layer_index,
        COALESCE(ca.actual_qty, 0) AS cutting_qty,
        COALESCE(ca.actual_qty, 0) - COALESCE(ng.net_ng_qty, 0) AS net_qty,
        COALESCE(bs.bonding_qty, 0) AS bonding_qty
      FROM production_order_items poi
      JOIN production_orders po ON poi.orderOrderId = po.order_id
      JOIN customers c ON po.customerCustomerId = c.customer_id
      JOIN products p ON poi.productProductId = p.product_id
      LEFT JOIN assembly_layers al ON p.product_id = al.productProductId
      LEFT JOIN (
        SELECT sku, week, COALESCE(sCode, 'MAIN') AS sCode, SUM(quantityProduksi) AS actual_qty
        FROM production_cutting_entries
        WHERE week IS NOT NULL
        GROUP BY sku, week, COALESCE(sCode, 'MAIN')
      ) ca ON p.sku = ca.sku AND poi.week_number = ca.week AND COALESCE(al.second_item_number, 'MAIN') = ca.sCode
      LEFT JOIN (
        SELECT 
          ng.sku,
          ng.s_code,
          MAX(ng.ng_qty - COALESCE(rp.replacement_qty, 0), 0) AS net_ng_qty
        FROM (
          SELECT br.sku, COALESCE(br.s_code, 'MAIN') AS s_code, SUM(br.ng_quantity) AS ng_qty
          FROM bonding_reject br
          WHERE br.status != 'CANCELLED'
          GROUP BY br.sku, COALESCE(br.s_code, 'MAIN')
        ) ng
        LEFT JOIN (
          SELECT 
            br.sku,
            COALESCE(br.s_code, 'MAIN') AS s_code,
            SUM(COALESCE(rp.processed_qty, 0)) AS replacement_qty
          FROM bonding_reject br
          LEFT JOIN replacement_progress rp ON br.id = rp.bonding_reject_id
          WHERE br.status != 'CANCELLED' AND rp.status IN ('IN_PROGRESS', 'COMPLETED')
          GROUP BY br.sku, COALESCE(br.s_code, 'MAIN')
        ) rp ON ng.sku = rp.sku AND ng.s_code = rp.s_code
        GROUP BY ng.sku, ng.s_code
      ) ng ON p.sku = ng.sku AND COALESCE(al.second_item_number, 'MAIN') = ng.s_code
      LEFT JOIN (
        SELECT sku, week, SUM(quantity_produksi) AS bonding_qty
        FROM bonding_summary
        GROUP BY sku, week
      ) bs ON p.sku = bs.sku AND poi.week_number = bs.week
      WHERE poi.week_number IS NOT NULL AND p.category = 'FOAM'
      ORDER BY c.customer_name, p.sku, poi.week_number, layer_index
    `);
  }
}